/**
 * Centralized processing logic for generating and storing trait embeddings
 * This module contains the core functionality that Nakama can utilize
 */

import { getOwnedFiles } from "@/lib/utils/hashAuthentication";
import { requestFile } from "@/lib/utils/s3cache";
import testVertexAIService from "../embedding/test-vertex-service";
import pineconeService from "@/backend/trait-embedding-service/src/services/pinecone-service";
import {
  PineconeUserMetadata,
  UserEmbedding,
} from "@/backend/trait-embedding-service/src/models/types";
import config from "@/backend/trait-embedding-service/src/config";

// Interfaces for type safety
export interface TraitData {
  source: string;
  traits: string[];
  hash?: string;
}

export interface ProcessingResult {
  success: boolean;
  userId?: string;
  traits?: TraitData[];
  combinedTraits?: string[];
  embedding?: number[];
  pineconeStored?: boolean;
  error?: string;
}

export interface ProcessingOptions {
  userId: string;
  skipTraitExtraction?: boolean;
  providedTraits?: string[];
  debug?: boolean;
}

/**
 * The main function that handles the entire trait processing pipeline
 * Can be called directly by the API route or by Nakama
 */
export async function processTraitsAndGenerateEmbedding(
  options: ProcessingOptions
): Promise<ProcessingResult> {
  const { userId, skipTraitExtraction, providedTraits, debug = false } = options;
  
  try {
    if (debug) console.log(`Starting trait processing for user ${userId}`);
    
    // STEP 1: Extract or use provided traits
    let traits: TraitData[] = [];
    let combinedTraits: string[] = [];
    
    if (!skipTraitExtraction && !providedTraits) {
      // Extract traits from user's chat files
      if (debug) console.log("Extracting traits from user chat files");
      const extractionResult = await extractUserTraits(userId);
      
      if (!extractionResult.success) {
        return {
          success: false,
          userId,
          error: extractionResult.error || "Failed to extract traits",
        };
      }
      
      traits = extractionResult.traits || [];
      combinedTraits = extractionResult.combinedTraits || [];
    } else if (providedTraits && providedTraits.length > 0) {
      // Use provided traits
      if (debug) console.log(`Using ${providedTraits.length} provided traits`);
      traits = [{ source: "provided", traits: providedTraits }];
      combinedTraits = providedTraits;
    } else {
      return {
        success: false,
        userId,
        error: "No traits available. Either extract from chat or provide traits.",
      };
    }
    
    if (combinedTraits.length === 0) {
      return {
        success: false,
        userId,
        error: "No traits found for processing",
      };
    }
    
    // STEP 2: Generate embedding using Vertex AI
    if (debug) console.log("Generating embedding with Vertex AI");
    const traitsText = combinedTraits.join(". ");
    
    let embedding: number[];
    try {
      embedding = await testVertexAIService.generateEmbedding(traitsText);
      
      if (!embedding || embedding.length === 0) {
        return {
          success: false,
          userId,
          traits,
          combinedTraits,
          error: "Empty embedding generated by Vertex AI",
        };
      }
      
      if (debug) console.log(`Generated ${embedding.length}-dimensional embedding`);
    } catch (embeddingError) {
      return {
        success: false,
        userId,
        traits,
        combinedTraits,
        error: `Error generating embedding: ${
          embeddingError instanceof Error ? embeddingError.message : String(embeddingError)
        }`,
      };
    }
    
    // STEP 3: Store in Pinecone
    if (debug) console.log(`Storing embedding in Pinecone for user ${userId}`);
    try {
      const currentTimestamp = new Date().toISOString();
      const embeddingDimension = config.pinecone.dimension;
      const embeddingModel = config.vertexAI.modelId;

      const userEmbeddingData: UserEmbedding = {
        userId,
        vector: embedding,
        dimension: embeddingDimension,
        model: embeddingModel,
        createdAt: currentTimestamp,
        updatedAt: currentTimestamp,
      };

      const pineconeMetadata: PineconeUserMetadata = {
        userId,
        seeking_match_status: true,
        opt_in_timestamp: currentTimestamp,
        missed_cycles_count: 0,
        updatedAt: currentTimestamp,
      };

      const success = await pineconeService.upsertEmbedding(
        userEmbeddingData,
        pineconeMetadata
      );

      if (!success) {
        return {
          success: false,
          userId,
          traits,
          combinedTraits,
          embedding,
          error: "Pinecone service reported failure during upsert",
        };
      }
      
      if (debug) console.log("Successfully stored embedding in Pinecone");
    } catch (pineconeError) {
      return {
        success: false,
        userId,
        traits,
        combinedTraits,
        embedding,
        error: `Error storing in Pinecone: ${
          pineconeError instanceof Error ? pineconeError.message : String(pineconeError)
        }`,
      };
    }
    
    // Return successful result
    return {
      success: true,
      userId,
      traits,
      combinedTraits,
      embedding,
      pineconeStored: true,
    };
  } catch (error) {
    // Handle any unexpected errors
    return {
      success: false,
      userId,
      error: `Unexpected error in processing pipeline: ${
        error instanceof Error ? error.message : String(error)
      }`,
    };
  }
}

/**
 * Extract traits from a user's chat files
 * This is separated out so it can be skipped if traits are provided directly
 */
async function extractUserTraits(_userId: string): Promise<{
  success: boolean;
  traits?: TraitData[];
  combinedTraits?: string[];
  error?: string;
}> {
  try {
    // Get all chat hashes owned by the user
    const ownedHashes = await getOwnedFiles();

    if (ownedHashes.length === 0) {
      return {
        success: false,
        error: "No chats found. Please upload chat data first.",
      };
    }

    const traitResults: TraitData[] = [];
    const allTraitsSet = new Set<string>();
    const BATCH_SIZE = 5; // Process 5 hashes concurrently

    for (let i = 0; i < ownedHashes.length; i += BATCH_SIZE) {
      const batchHashes = ownedHashes.slice(i, i + BATCH_SIZE);
      
      const batchPromises = batchHashes.map(async (hash) => {
        try {
          // Get users for this chat and personality data concurrently
          const [chatUsersData, personalityDataResult] = await Promise.all([
            requestFile(
              `chat/${hash}/people.json`,
              hash,
              "fake", // Using "fake" to trigger requestFileWithAuth
              () => Promise.resolve("fake"), // Dummy refresh token function
              false
            ),
            requestFile(
              `chat/${hash}/personality-insights.json`,
              hash,
              "fake",
              () => Promise.resolve("fake"),
              false
            ),
          ]);

          // Process chatUsersData
          const chatUsers = chatUsersData as any;
          if (!chatUsers || !Array.isArray(chatUsers)) {
            return null;
          }

          const meUser = chatUsers.find((user: any) => user.isMe);
          if (!meUser) {
            return null;
          }

          // Process personalityDataResult
          let parsedPersonalityData;
          if (typeof personalityDataResult === "string") {
            try {
              parsedPersonalityData = JSON.parse(personalityDataResult);
            } catch (err) {
              return null;
            }
          } else {
            parsedPersonalityData = personalityDataResult;
          }

          if (!parsedPersonalityData) {
            return null;
          }

          let foundTraits: string[] = [];
          if (parsedPersonalityData[meUser.username]?.essence_profile) {
            foundTraits = parsedPersonalityData[meUser.username].essence_profile;
          } else if (
            parsedPersonalityData.X?.essence_profile &&
            parsedPersonalityData.Z?.essence_profile
          ) {
            const meIndex = chatUsers.findIndex((user: any) => user.isMe);
            const xOrZ = meIndex === 0 ? "X" : "Z"; // Assuming X is user 0, Z is user 1
            if (parsedPersonalityData[xOrZ]?.essence_profile) {
              foundTraits = parsedPersonalityData[xOrZ].essence_profile;
            }
          } else if (
            parsedPersonalityData.user1?.essence_profile &&
            parsedPersonalityData.user2?.essence_profile
          ) {
            const meIndex = chatUsers.findIndex((user: any) => user.isMe);
            const userKey = meIndex === 0 ? "user1" : "user2";
            if (parsedPersonalityData[userKey]?.essence_profile) {
              foundTraits = parsedPersonalityData[userKey].essence_profile;
            }
          }

          if (foundTraits.length > 0) {
            const cleanedTraits = foundTraits
              .map((trait) => trait.trim())
              .filter(Boolean);
            return {
              source: hash.substring(0, 8),
              traits: cleanedTraits,
              hash,
            };
          }
          return null;
        } catch (error) {
          console.error(
            `Error processing chat ${hash.substring(0, 8)}...:`,
            error instanceof Error ? error.message : String(error)
          );
          return null;
        }
      });

      const resultsForBatch = await Promise.all(batchPromises);

      resultsForBatch.forEach((result) => {
        if (result) {
          traitResults.push({
            source: result.source,
            traits: result.traits,
          });
          result.traits.forEach((trait) => allTraitsSet.add(trait));
        }
      });
    }

    if (traitResults.length === 0) {
      return {
        success: false,
        error: "Could not extract any traits from the available chats",
      };
    }

    return {
      success: true,
      traits: traitResults,
      combinedTraits: Array.from(allTraitsSet),
    };
  } catch (error) {
    return {
      success: false,
      error: `Error extracting traits: ${
        error instanceof Error ? error.message : String(error)
      }`,
    };
  }
}